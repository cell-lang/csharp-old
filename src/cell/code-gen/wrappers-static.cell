implicit block_name : DBSymbol, db_var_chain : NestedDBVar*, root_block_name : DBSymbol {
  String external_name(<MembVar, RelVar, MethodSymbol> var) =
    append((sentence_case(bare_id(v)) : v <- (db_var_chain | var)), "_");

  String path_prefix = "automaton." & append((to_c_var_decl_name(v) & "." : v <- db_var_chain));

  String full_path(<MembVar, RelVar> var) = path_prefix & to_c_var_decl_name(var);

  String db_class_name = upper_camel_case(bare_id(root_block_name));
}


implicit block_name : DBSymbol, db_var_chain : NestedDBVar*, root_block_name : DBSymbol, typedefs : [TypeName -> NeType] {
  (String*, String*) state_var_accessor(MembVar var, NeType var_type) {
    inter_type = output_interface_type(var_type);
    base_name = external_name(var);
    meth_name = "Get_" & base_name;
    var_name = to_c_var_decl_name(var);
    ret_type = return_value_type(inter_type);

    body = export_code(inter_type, full_path(var), "return ");
    code = ("", "public " & ret_type & " " & meth_name & "() {") & indent_lines(body) & ("}");

    return (code, (ret_type & " " & meth_name & "();"));
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) unary_table_accessors(RelVar relvar, ValueStoreId value_store_id, NeType elem_type) {
    input_type = input_interface_type(elem_type);
    output_type = output_interface_type(elem_type);
    base_name = external_name(relvar);
    rel_name = to_c_var_decl_name(relvar);
    relvar_path = full_path(relvar);
    val_store_name = to_c_var_decl_name(value_store_id);
    ret_elem_type = return_value_type(output_type);
    arg_type = input_arg_type(input_type);
    ctor_fn = constructor_function(input_type);

    code = (
      "",
      "public bool In_" & base_name & "(" & arg_type & " value) {",
      "  int surr = " & relvar_path & ".store.LookupValue(" & ctor_fn & "(value));",
      "  return surr != -1 && " & relvar_path & ".Contains((uint) surr);",
      "}",
      "",
      "public " & ret_elem_type & "[] " & "Get_" & base_name & "() {",
      "  uint size = " & relvar_path & ".Size();",
      "  " & ret_elem_type & "[] copy = new " & array_new_expr(output_type, "size") & ";",
      "  UnaryTable.Iter it = " & relvar_path & ".GetIter();",
      "  int next = 0;",
      "  while (!it.Done()) {"
    ) & indent_lines(indent_lines(
      export_code(output_type, relvar_path & ".store.LookupSurrogate(it.Get())", "copy[next++] = ")
    )) & (
      "    it.Next();",
      "  }",
      "  Miscellanea.Assert(next == size);",
      "  return copy;",
      "}"
    );

    docs = (
      "",
      "bool In_" & base_name & "(" & arg_type & ");",
      ret_elem_type & "[] Get_" & base_name & "();"
    );

    return (code, docs);
  }

  //////////////////////////////////////////////////////////////////////////////

  (T, T) flip_pair_if((T, T) pair, Bool cond) {
    if cond:
      a, b = pair;
      return (b, a);
    else
      return pair;
    ;
  }


  (String*, String*) binary_table_accessors(RelVar relvar, (ValueStoreId, ValueStoreId) value_store_ids,
    (NeType, NeType) perm_types, Maybe[Nat] maybe_key_col, Bool flipped) {
    types = flip_pair_if(perm_types, flipped);
    input_types = (input_interface_type(t) : t <- types);
    output_types = (output_interface_type(t) : t <- types);
    base_name = external_name(relvar);
    rel_name = to_c_var_decl_name(relvar);
    relvar_path = full_path(relvar);
    ret_types = (return_value_type(t) : t <- output_types);
    args_types = (input_arg_type(t) : t <- input_types);
    args_decls = (t & " arg" & printed(i) : t @ i <- args_types);
    ctor_fns = (constructor_function(it) : it <- input_types);
    args_convs = flip_pair_if((f & "(arg" & printed(i) & ")" : f @ i <- ctor_fns), flipped);

    body_instr = "  return WrappingUtils.TableContains(" & relvar_path & ", " & append(args_convs, ", ") & ");";
    code = ("", "public bool In_" & base_name & "(" & append(args_decls, ", ") & ") {", body_instr, "}");
    docs = ("", "bool In_" & base_name & "(" & append(args_types, ", ") & ");");

    if maybe_key_col != nothing:
      key_col = value(maybe_key_col);
      assert key_col == 0;
      non_key_col = match (key_col) 0 = 1, 1 = 0;
      key_col, non_key_col = (non_key_col, key_col) if flipped;
      in_type = args_types(key_col);
      out_type = ret_types(non_key_col);

      code = code & (
        "",
        "public " & out_type & " Lookup_" & base_name & "(" & in_type & " key) {",
        "  int surr1 = " & relvar_path & ".store1.LookupValue(" & ctor_fns(key_col) & "(key));",
        "  if (surr1 == -1)",
        "    throw new KeyNotFoundException();",
        "  BinaryTable.Iter it = " & relvar_path & ".GetIter1((uint) surr1);",
        "  if (it.Done())",
        "    throw new KeyNotFoundException();",
        "  Miscellanea.Assert(it.GetField1() == surr1);",
        "  uint surr2 = it.GetField2();",
        "  it.Next();",
        "  Miscellanea.Assert(it.Done());"
      ) & export_code(
            output_types(non_key_col),
            relvar_path & ".store2.LookupSurrogate(surr2)",
            "return "
      ) & ("}");

      docs = (docs | out_type & " Lookup_" & base_name & "(" & in_type & "); // Throws KeyNotFoundException() if no corresponding tuple is found");
    ;

    types_str = append(ret_types, ", ");
    sgn = "public Tuple<" & types_str & ">[] Get_" & base_name & "()";
    body = (
      "int size = " & relvar_path & ".Size();",
      "Tuple<" & types_str & ">[] copy = new Tuple<" & types_str & ">[size];",
      "BinaryTable.Iter it = " & relvar_path & ".GetIter();",
      "int next = 0;",
      "while (!it.Done()) {"
    ) & export_code(
      output_types(0),
      relvar_path & ".store1.LookupSurrogate(it.GetField1())",
      "  " & ret_types(0) & " field1 = "
    ) & export_code(
      output_types(1),
      relvar_path & ".store2.LookupSurrogate(it.GetField2())",
      "  " & ret_types(1) & " field2 = "
    ) & (
      "  copy[next++] = new Tuple<" & types_str & ">(field1, field2);",
      "  it.Next();",
      "}",
      "Miscellanea.Assert(next == size);",
      "return copy;"
    );

    code = (code | "", sgn & " {") & indent_lines(body) & ("}");
    docs = (docs | sgn & ";");

    return (code, docs);
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) ternary_table_accessors(RelVar relvar,
    (ValueStoreId, ValueStoreId, ValueStoreId) value_store_ids,
    (NeType, NeType, NeType) perm_types, (Nat, Nat, Nat) applied_perm) {

    rev_perm = reverse_perm(applied_perm);
    types = (perm_types(i) : i <- rev_perm);
    assert (types(i) : i <- applied_perm) == perm_types;

    input_types = (input_interface_type(t) : t <- types);
    output_types = (output_interface_type(t) : t <- types);

    ret_types = (return_value_type(t) : t <- output_types);
    ret_types_str = append(ret_types, ", ");

    args_types = (input_arg_type(t) : t <- input_types);
    ctor_fns = (constructor_function(it) : it <- input_types);

    rel_name = to_c_var_decl_name(relvar);
    base_name = external_name(relvar);
    relvar_path = full_path(relvar);

    args_decls = append((t & " arg" & printed(i) : t @ i <- args_types), ", ");
    cols_perm_args = append((printed(i) : i <- rev_perm), ", ");
    args_convs = (ctor_fns(i) & "(arg" & printed(i) & ")" : i <- applied_perm);

    code = (
      "",
      "public bool In_" & base_name & "(" & args_decls & ") {",
      "  int surr1 = " & relvar_path & ".store1.LookupValue(" & args_convs(0) & ");",
      "  if (surr1 == -1)",
      "    return false;",
      "  int surr2 = " & relvar_path & ".store2.LookupValue(" & args_convs(1) & ");",
      "  if (surr2 == -1)",
      "    return false;",
      "  int surr3 = " & relvar_path & ".store3.LookupValue(" & args_convs(2) & ");",
      "  if (surr3 == -1)",
      "    return false;",
      "  return " & relvar_path & ".Contains((uint) surr1, (uint) surr2, (uint) surr3);",
      "}",
      "",
      "public Tuple<" & ret_types_str & ">[] " & "Get_" & base_name & "() {",
      "  int size = " & relvar_path & ".Size();",
      "  Tuple<" & ret_types_str & ">[] copy = new Tuple<" & ret_types_str & ">[size];",
      "  TernaryTable.Iter it = " & relvar_path & ".GetIter();",
      "  int next = 0;",
      "  while (!it.Done()) {"
      ) & export_code(
        output_types(0),
        relvar_path & ".store1.LookupSurrogate(it.GetField1())",
        "    " & ret_types(0) & " field1 = "
      ) & export_code(
        output_types(1),
        relvar_path & ".store2.LookupSurrogate(it.GetField2())",
        "    " & ret_types(1) & " field2 = "
      ) & export_code(
        output_types(2),
        relvar_path & ".store3.LookupSurrogate(it.GetField3())",
        "    " & ret_types(2) & " field3 = "
      ) & (
      "    copy[next++] = new Tuple<" & ret_types_str & ">(field1, field2, field3);",
      "    it.Next();",
      " }",
      "  Miscellanea.Assert(next == size);",
      "  return copy;",
      "}"
    );

    docs = (
      "",
      "bool In_" & base_name & "(" & args_decls & ") {",
      "Tuple<" & ret_types_str & ">[] " & "Get_" & base_name & "()"
    );

    return (code, docs);
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) table_accessors(RelVar relvar, Table table) {
    return match (table.value_stores, table.col_types, table.applied_perm)
      (vs?),     (t?),      (_)       = unary_table_accessors(relvar, vs, t),
      (_, _),    (_, _),    (_, _)    = binary_table_accessors(relvar, table.value_stores, table.col_types,
                                          maybe_key_col(table), table.applied_perm != (0, 1)),
      (_, _, _), (_, _, _), (_, _, _) = ternary_table_accessors(relvar, table.value_stores, table.col_types,
                                          table.applied_perm);


    Maybe[Nat] maybe_key_col(Table table) {
      keys = table.keys;
      if |keys| == 1:
        key = only(keys);
        return just(only(key)) if |key| == 1;
      ;
      return nothing;
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) db_method_wrapper(MethodId method_id, CompiledMethod method) {
    if not method_id.id?:
      base_name = external_name(method_id.symbol);
      return method_wrapper(method_id, method, block_name, base_name, db_class_name, path_prefix);
    else
      return ((), ());
    ;
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) static_auto_accessors(StaticBlock block, [DBSymbol -> StaticBlock] blocks) {
    state_var_accessors = isort([state_var_accessor(v, t) : v, t <- block.state_vars]);
    state_var_accessors_code, state_var_accessors_docs = (join(ls) : ls <- unzip(state_var_accessors));

    table_accessors = isort([table_accessors(v, t) : v, t <- block.tables]);
    table_accessors_code, table_accessors_docs = (join(ls) : ls <- unzip(table_accessors));

    methods_wrappers = isort([db_method_wrapper(id, m) : id, m <- block.methods]);
    methods_wrappers_code, methods_wrappers_docs = (join(ls) : ls <- unzip(methods_wrappers));

    nested_autos_accessors = isort([
        static_auto_accessors(blocks[t], blocks, block_name = blocks[t].name, db_var_chain = (db_var_chain | v))
      : v, t <- block.nested_blocks
    ]);
    nested_autos_code, nested_autos_docs = (join(ls) : ls <- unzip(nested_autos_accessors));

    code = methods_wrappers_code & state_var_accessors_code & table_accessors_code & nested_autos_code;

    docs_by_type = (state_var_accessors_docs, table_accessors_docs, methods_wrappers_docs, nested_autos_docs);
    docs = join(intermix((indent_lines(d) : d <- docs_by_type, d != ()), ("")));

    return (code, docs);
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  (String*, String*) static_auto_wrapper(StaticBlock root_block, [DBSymbol -> StaticBlock] blocks) {
    let block_name = root_block.name, db_var_chain = (), root_block_name = root_block.name:
      accessors_code, accessors_docs = static_auto_accessors(root_block, blocks);
      class_name = db_class_name;
    ;

    db_name = to_c_name(root_block.name);
    updater_name = aux_struct_c_name(root_block.name);
    has_any_updates = root_block.msg_memb_pred != nothing;

    links_types = (upper_camel_case(bare_id(l)) : l <- root_block.links);

    ctor_impl_args = (t & " l" & printed(i) : t @ i <- links_types);

    class_impl = (
      "public class " & class_name & " {",
      "  Env env;",
      "  " & db_name & " automaton;",
      "  " & updater_name & " updater;",
      "",
      "  public " & class_name & "(" & append(ctor_impl_args, ", ") & ") {",
      "    env = new Env();",
      "    automaton = new " & db_name & "(env);",
      "    updater = automaton.NewUpdater();",
      "  }",
      "",
      "  public CellLang.Value ReadState() {",
      "    Obj " & native_method_call("obj", "automaton", copy_state_proc_name(root_block.name), ()),
      "    return Conversions.ExportAsValue(obj);",
      "  }",
      "",
      "  public void SetState(String text) {",
      "    Obj obj = Conversions.ConvertText(text);",
      "    if (!" & to_c_fn_name(root_block.state_memb_pred) & "(obj))",
      "      throw new Exception(\"Invalid state\");",
      "    bool " & native_method_call("ok", "automaton", set_state_entry_point_name(root_block.name), ("obj", "updater")),
      "    if (!ok)",
      "      throw new Exception(\"Invalid state\");",
      "  }"
    );

    if has_any_updates:
      class_impl = class_impl & (
        "",
        "  public void Execute(String text) {",
        "    Obj msg = Conversions.ConvertText(text);",
        "    if (!" & to_c_fn_name(value_unsafe(root_block.msg_memb_pred)) & "(msg))",
        "      throw new Exception(\"Invalid message\");",
        "    bool " & native_method_call("ok", "automaton", update_entry_point_name(root_block.name), ("msg", "updater", "env")),
        "    if (!ok) {",
        "      env = new Env();",
        "      throw new Exception(\"Update failed\");",
        "    }",
        "  }"
      );
    ;

    class_impl = class_impl & indent_lines(accessors_code) & ("}") ;

    class_docs = (
      "class CellLang.Generated." & class_name & " {",
      "  " & class_name & "(" & append(ctor_impl_args, ", ") & ");",
      "",
      "  CellLang.Value ReadState();",
      "  void SetState(String);",
      "  void Execute(String);" if has_any_updates
    );
    class_docs = class_docs & ("") & accessors_docs if accessors_docs != ();
    class_docs = (class_docs | "}");

    return (class_impl, class_docs);
  }
}
