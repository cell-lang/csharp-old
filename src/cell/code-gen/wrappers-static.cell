implicit block_name : DBSymbol, db_var_chain : NestedDBVar*, root_block_name : DBSymbol {
  String external_name(<MembVar, RelVar, MethodSymbol> var) =
    append((sentence_case(bare_id(v)) : v <- (db_var_chain | var)), "_");

  String db_class_name = upper_camel_case(bare_id(root_block_name));

  String ptr_def_instr {
    expr = "(" & to_c_name(root_block_name) & " *) ptr";
    expr = "&(" & expr & ")->" & append((to_c_var_decl_name(v) : v <- db_var_chain), ".") if db_var_chain != ();
    return "  " & to_c_name(block_name) & " *self = " & expr & ";";
  }
}


implicit block_name : DBSymbol, db_var_chain : NestedDBVar*, root_block_name : DBSymbol, typedefs : [TypeName -> NeType] {
  (String*, String*) state_var_accessor(MembVar var, NeType var_type) {
    inter_type = output_interface_type(var_type);
    base_name = external_name(var);
    meth_name = "get_" & base_name;
    var_name = to_c_var_decl_name(var);
    ret_type = return_value_type(inter_type);

    decl = "  " & ret_type & meth_name & "();";

    impl = (
      "",
      ret_type & db_class_name & "::" & meth_name & "() {",
      ptr_def_instr,
      "  return " & export_expr(inter_type, "self->" & var_name) & ";",
      "}"
    );

    return ((decl), impl);
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) unary_table_accessors(RelVar relvar, ValueStoreId value_store_id, NeType elem_type) {
    input_type = input_interface_type(elem_type);
    output_type = output_interface_type(elem_type);
    base_name = external_name(relvar);
    rel_name = to_c_var_decl_name(relvar);
    val_store_name = to_c_var_decl_name(value_store_id);
    ret_elem_type = return_value_type(output_type);
    arg_type = input_arg_type(input_type);
    ctor_fn = constructor_function(input_type);

    code = (
      "",
      "bool in_" & base_name & "(" & arg_type & " value) {",
      "  int surr = automaton." & rel_name & ".store.LookupValue(" & ctor_fn & "(value));",
      "  return surr != -1 && automaton." & rel_name & ".Contains((uint) surr);",
      "}",
      "",
      ret_elem_type & "[] " & "get_" & base_name & "() {",
      "  uint size = automaton." & rel_name & ".Size();",
      "  " & ret_elem_type & "[] copy = new " & ret_elem_type & "[size];",
      "  UnaryTable.Iter it = automaton." & rel_name & ".GetIter();",
      "  int next = 0;",
      "  while (!it.Done()) {",
      "    copy[next++] = " & export_expr(output_type, "automaton." & rel_name & ".store.LookupSurrogate(it.Get())") & ";",
      "    it.Next();",
      "  }",
      "  Miscellanea.Assert(next == size);",
      "  return copy;",
      "}"
    );

    docs = (
      "",
      "bool in_" & base_name & "(" & arg_type & ");",
      ret_elem_type & "[] get_" & base_name & "();"
    );

    return (code, docs);
  }

  //////////////////////////////////////////////////////////////////////////////

  (T, T) flip_pair_if((T, T) pair, Bool cond) {
    if cond:
      a, b = pair;
      return (b, a);
    else
      return pair;
    ;
  }


  (String*, String*) binary_table_accessors(RelVar relvar, (ValueStoreId, ValueStoreId) value_store_ids,
    (NeType, NeType) perm_types, Maybe[Nat] maybe_key_col, Bool flipped) {
    types = flip_pair_if(perm_types, flipped);
    input_types = (input_interface_type(t) : t <- types);
    output_types = (output_interface_type(t) : t <- types);
    base_name = external_name(relvar);
    rel_name = to_c_var_decl_name(relvar);
    ret_types = (return_value_type(t) : t <- output_types);
    args_types = (input_arg_type(t) : t <- input_types);
    args_decls = (t & "arg" & printed(i) : t @ i <- args_types);
    ctor_fns = (constructor_function(it) : it <- input_types);
    args_convs = flip_pair_if((f & "(arg" & printed(i) & ")" : f @ i <- ctor_fns), flipped);

    body_instr = "  return WrappingUtils.TableContains(automaton." & rel_name & ", " & append(args_convs, ", ") & ");";
    code = ("", "public bool in_" & base_name & "(" & append(args_decls, ", ") & ") {", body_instr, "}");
    docs = ("", "bool in_" & base_name & "(" & append(args_types, ", ") & ");");

    if maybe_key_col != nothing:
      key_col = value(maybe_key_col);
      assert key_col == 0;
      non_key_col = match (key_col) 0 = 1, 1 = 0;
      key_col, non_key_col = (non_key_col, key_col) if flipped;
      in_type = args_types(key_col);
      out_type = ret_types(non_key_col);

      code = code & (
        "",
        out_type & " lookup_" & base_name & "(" & in_type & "key) {",
        "  int surr1 = automaton." & rel_name & ".store1.LookupValue(" & ctor_fns(key_col) & "(key));",
        "  if (surr1 == -1)",
        "    throw new KeyNotFoundException();",
        "  BinaryTable.Iter it = automaton." & rel_name & ".GetIter1((uint) surr1);",
        "  if (it.Done())",
        "    throw new KeyNotFoundException();",
        "  Miscellanea.Assert(it.GetField1() == surr1);",
        "  uint surr2 = it.GetField2();",
        "  it.Next();",
        "  Miscellanea.Assert(it.Done());",
        "  return " & export_expr(output_types(non_key_col), "automaton." & rel_name & ".store2.LookupSurrogate(surr2)") & ";",
        "}"
      );

      docs = (docs | out_type & " lookup_" & base_name & "(" & in_type & "); // Throws KeyNotFoundException() if no corresponding tuple is found");
    ;

    types_str = append(ret_types, ", ");
    sgn = "public Tuple<" & types_str & ">[] get_" & base_name & "()";
    body = (
      "int size = automaton." & rel_name & ".Size();",
      "Tuple<" & types_str & ">[] copy = new Tuple<" & types_str & ">[size];",
      "BinaryTable.Iter it = automaton." & rel_name & ".GetIter();",
      "int next = 0;",
      "while (!it.Done()) {",
      "  " & ret_types(0) & "field1 = " & export_expr(input_types(0), "automaton." & rel_name & ".store1.LookupSurrogate(it.GetField1())") & ";",
      "  " & ret_types(1) & "field2 = " & export_expr(input_types(1), "automaton." & rel_name & ".store2.LookupSurrogate(it.GetField2())") & ";",
      "  copy[next++] = new Tuple<" & types_str & ">(field1, field2);",
      "  it.Next();",
      "}",
      "Miscellanea.Assert(next == size);",
      "return copy;"
    );

    code = (code | "", sgn & " {") & indent_lines(body) & ("}");
    docs = (docs | sgn & ";");

    return (code, docs);
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) ternary_table_accessors(RelVar relvar,
    (ValueStoreId, ValueStoreId, ValueStoreId) value_store_ids,
    (NeType, NeType, NeType) perm_types, (Nat, Nat, Nat) applied_perm) {

    rev_perm = reverse_perm(applied_perm);
    types = (perm_types(i) : i <- rev_perm);
    assert (types(i) : i <- applied_perm) == perm_types;

    input_types = (input_interface_type(t) : t <- types);
    output_types = (output_interface_type(t) : t <- types);

    ret_types = append((return_value_type(t) : t <- output_types), ", ");
    args_types = (input_arg_type(t) : t <- input_types);
    ctor_fns = (constructor_function(it) : it <- input_types);
    base_name = external_name(relvar);

    conv_traits = append((conversion_trait(it) : it <- output_types), ", ");
    args_decls = append((t & "arg" & printed(i) : t @ i <- args_types), ", ");
    fixed_args = append(("self->" & to_c_var_decl_name(vs_id) : vs_id <- (relvar) & value_store_ids), ", ");
    cols_perm_args = append((printed(i) : i <- rev_perm), ", ");
    args_convs = append((ctor_fns(i) & "(arg" & printed(i) & ")" : i <- applied_perm), ", ");

    code = (
      "",
      "bool in_" & base_name & "(" & args_decls & ") {",
      ptr_def_instr,
      "  return table_contains(" & fixed_args & ", " & args_convs & ");",
      "}",
      "",
      "std::vector<std::tuple<" & ret_types & "> > " & db_class_name & "::get_" & base_name & "() {",
      ptr_def_instr,
      "  return get_ternary_rel<" & conv_traits & ">(" & fixed_args & ", " & cols_perm_args & ");",
      "}"
    );

    docs = (
      "  bool in_" & base_name & "(" & append(args_types, ", ") & ");",
      "  std::vector<std::tuple<" & ret_types & "> > get_" & base_name & "();"
    );

    return (code, docs);
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) table_accessors(RelVar relvar, Table table) {
    return match (table.value_stores, table.col_types, table.applied_perm)
      (vs?),     (t?),      (_)       = unary_table_accessors(relvar, vs, t),
      (_, _),    (_, _),    (_, _)    = binary_table_accessors(relvar, table.value_stores, table.col_types,
                                          maybe_key_col(table), table.applied_perm != (0, 1)),
      (_, _, _), (_, _, _), (_, _, _) = ternary_table_accessors(relvar, table.value_stores, table.col_types,
                                          table.applied_perm);


    Maybe[Nat] maybe_key_col(Table table) {
      keys = table.keys;
      if |keys| == 1:
        key = only(keys);
        return just(only(key)) if |key| == 1;
      ;
      return nothing;
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) db_method_wrapper(MethodId method_id, CompiledMethod method) {
    if not method_id.id?:
      base_name = external_name(method_id.symbol);
      return method_wrapper(method_id, method, block_name, base_name, db_class_name);
    else
      return ((), ());
    ;
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) static_auto_accessors(StaticBlock block, [DBSymbol -> StaticBlock] blocks) {
    state_var_accessors = isort([state_var_accessor(v, t) : v, t <- block.state_vars]);
    state_var_accessors_code, state_var_accessors_docs = (join(ls) : ls <- unzip(state_var_accessors));

    table_accessors = isort([table_accessors(v, t) : v, t <- block.tables]);
    table_accessors_code, table_accessors_docs = (join(ls) : ls <- unzip(table_accessors));

    methods_wrappers = isort([db_method_wrapper(id, m) : id, m <- block.methods]);
    methods_wrappers_code, methods_wrappers_docs = (join(ls) : ls <- unzip(methods_wrappers));

    nested_autos_accessors = isort([
        static_auto_accessors(blocks[t], blocks, block_name = blocks[t].name, db_var_chain = (db_var_chain | v))
      : v, t <- block.nested_blocks
    ]);
    nested_autos_code, nested_autos_docs = (join(ls) : ls <- unzip(nested_autos_accessors));

    code = methods_wrappers_code & state_var_accessors_code & table_accessors_code & nested_autos_code;

    docs_by_type = (state_var_accessors_docs, table_accessors_docs, methods_wrappers_docs, nested_autos_docs);
    docs = join(intermix((indent_lines(d) : d <- docs_by_type, d != ()), ("")));

    return (code, docs);
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  (String*, String*) static_auto_wrapper(StaticBlock root_block, [DBSymbol -> StaticBlock] blocks) {
    let block_name = root_block.name, db_var_chain = (), root_block_name = root_block.name:
      accessors_code, accessors_docs = static_auto_accessors(root_block, blocks);
      class_name = db_class_name;
    ;

    db_name = to_c_name(root_block.name);
    updater_name = aux_struct_c_name(root_block.name);
    has_any_updates = root_block.msg_memb_pred != nothing;

    links_types = (upper_camel_case(bare_id(l)) : l <- root_block.links);

    ctor_impl_args = (t & " l" & printed(i) : t @ i <- links_types);

    class_impl = (
      "public class " & class_name & " {",
      "  Env env;",
      "  " & db_name & " automaton;",
      "  " & updater_name & " updater;",
      "",
      "  public " & class_name & "(" & append(ctor_impl_args, ", ") & ") {",
      "    env = new Env();",
      "    automaton = new " & db_name & "(env);",
      "    updater = automaton.NewUpdater();",
      "  }",
      "",
      "  public CellLang.Value ReadState() {",
      "    Obj " & native_method_call("obj", "automaton", copy_state_proc_name(root_block.name), ()),
      "    return Conversions.ExportAsValue(obj);",
      "  }",
      "",
      "  public void SetState(String text) {",
      "    Obj obj = Conversions.ConvertText(text);",
      "    if (!" & to_c_fn_name(root_block.state_memb_pred) & "(obj))",
      "      throw new Exception();",
      "    bool " & native_method_call("ok", "automaton", set_state_entry_point_name(root_block.name), ("obj", "updater")),
      "    if (!ok)",
      "      throw new Exception();",
      "  }"
    );

    if has_any_updates:
      class_impl = class_impl & (
        "",
        "  public void Execute(String text) {",
        "    Obj msg = Conversions.ConvertText(text);",
        "    if (!" & to_c_fn_name(value_unsafe(root_block.msg_memb_pred)) & "(msg))",
        "      throw new Exception();",
        "    bool " & native_method_call("ok", "automaton", update_entry_point_name(root_block.name), ("msg", "updater", "env")),
        "    if (!ok)",
        "      throw new Exception();",
        "  }"
      );
    ;

    class_impl = class_impl & indent_lines(accessors_code) & ("}") ;

    class_docs = (
      "class CellLang.Generated." & class_name & " {",
      "  " & class_name & "(" & append(ctor_impl_args, ", ") & ");",
      "",
      "  CellLang.Value ReadState();",
      "  void SetState(String);",
      "  void Execute(String);" if has_any_updates
    );
    class_docs = class_docs & ("") & accessors_docs if accessors_docs != ();
    class_docs = (class_docs | "}");

    return (class_impl, class_docs);
  }
}
