implicit {
  sorted_cls_defs                 : ClsDef*,
  int_seqs_types_and_lengths      : (String, Nat)*,
  cached_semi_consts_by_impl_arg  : [ImplArg -> [+FnId]];


//  String auto_expr_native_code(RefObjExpr expr, WriteObjVar var) {
//    res_cs = auto_expr_native_code_cs(expr, var);
//    res_cpp = auto_expr_native_code_cpp(expr, var);
//    print "--  --  --  --  --  --  --  --  --  --  --  --  --  --";
//    print expr;
//    print var;
//    print res_cs;
//    print res_cpp;
//    assert res_cs != "";
//    return res_cs;
//  }


  String auto_expr_native_code(RefObjExpr expr, WriteObjVar var) =
    copy_state()              = native_method_call(var, expr.var, copy_state_proc_name(expr.type), ()),
    copy_table()              = native_copy_table_code(var, expr.relvar, expr.table, expr.perm),
    copy_persistent_state()   = native_method_call(var, expr.var, copy_state_proc_name(expr.type), ()),
    lookup_surrogate()        = native_method_call(var, expr.store, "LookupSurrogate", (expr.surrogate)),
    read_pending_var(v?)      = to_c_var_ref_name(var) & " = " & to_c_var_ref_name(v) & ";";


//  String compile_copy_persistent_state_to_c(WriteObjVar res_var, AnyAutoVar auto_var, AutoSymbol type) {
//    proc_name_str = copy_state_proc_name(type);
//    auto_var_str = "&" & to_c_var_ref_name(auto_var);
//    return mk_gen_call(res_var, proc_name_str, (auto_var_str), (), ());
//  }




  String native_copy_table_code(WriteObjVar res_var, RelVar relvar, Table table, Nat+ perm) {
    perm_args = match (perm)
      (_)       = (),
      (0, 1)    = (false),
      (1, 0)    = (true),
      (_, _, _) = perm;
    return native_method_call(res_var, "Copy", table.value_stores & perm_args);
  }


//  String native_copy_state_code(WriteObjVar res_var, AnyDBVar db_var, DBSymbol type) {
//    proc_name_str = copy_state_proc_name(type);
//    db_var_str = "&" & to_c_var_ref_name(db_var);
//    return mk_gen_call(res_var, proc_name_str, (db_var_str), (), ());
//  }


//  String auto_expr_native_code_cpp(RefObjExpr expr, WriteObjVar var) =
//    copy_state()                = compile_copy_state_to_c(var, expr.var, expr.type),
//    copy_table()                = compile_copy_table_to_c(var, expr.relvar, expr.table, expr.perm),
//    copy_persistent_state()     = compile_copy_persistent_state_to_c(var, expr.var, expr.type),
//    lookup_surrogate()          = native_static_call(var, "lookup_surrogate", (expr.store, expr.surrogate)),
//    read_pending_var(v?)        = to_c_var_ref_name(var) & " = " & to_c_var_ref_name(v) & ";";







//  String* auto_instr_native_code(Instr instr, Maybe[Nat] block_id) {
//    res_cs = native_code_cs(instr, block_id);
//    res_cpp = native_code_cpp(instr, block_id);
//    print "-------------------------------------------------------";
//    print instr;
//    print res_cpp;
//    print res_cs;
//    assert res_cs != ();
//    return res_cs;
//  }

//  String* compile_queue_update_to_c(AutoSymbol type, BlockNodeId node_id, Nat* args) {
//    method_name = queue_update_method_name(type, node_id);
//    args_str = append((", " & printed(a) : a <- args));
//    return (method_name & "(self" & args_str & ");");
//  }



  String* auto_instr_native_code(Instr instr, Maybe[Nat] block_id) =
    try_block()           = native_try_block_code(instr.var, instr.body, block_id),

    queue_update()        = (native_method_call("self", queue_update_method_name(instr.type, instr.id), instr.args)),

    insert_timer()        = (native_method_call("self", insert_timer_method_name(instr.type), (instr.idx, instr.time))),
    clear_timer()         = (native_method_call("self", clear_timer_method_name(instr.type), (instr.idx))),

    auto_pre_init()       = (native_method_call(instr.var, pre_init_method_name(instr.type), ("env"))),
    auto_cleanup()        = (native_method_call(instr.var, cleanup_method_name(instr.type), ())),
    clear_input()         = (native_method_call(if instr.var? then instr.var else "self", input_set_method_name(instr.type, instr.input), ("null"))),
    auto_update_node()    = (native_method_call("this", node_update_method_name(instr.type, instr.node), (instr.time_var if instr.time_var?, "self_aux", "env"))),

    set_input()           = (native_method_call(instr.var, input_set_method_name(instr.type, instr.input), (instr.value))),
    auto_apply()          = (native_method_call(if instr.var? then instr.var else "self", apply_method_name(instr.type), ())),

    set_persistent_state()  = (native_method_call(instr.auto_var, set_state_proc_name(instr.type), (instr.state))),

    init_db()             = (native_method_call(instr.db_var, init_method_name(instr.type), (instr.links | "env"))),
    cleanup_db()          = (native_method_call(instr.db_var, cleanup_method_name(instr.type), ())),

    send_msg()            = (native_send_msg_code(instr.db_var, instr.type, instr.msg, instr.is_root, if instr.res_var? then just(instr.res_var) else nothing)),
    try_update()          = (native_method_call("self", update_name(instr.type, instr.update_id), (instr.args | "this_aux", "env"))),
    set_state()           = (native_set_state_code(instr.state, instr.db_var, instr.type, if instr.res_var? then just(instr.res_var) else nothing)),
    invoke_auto_method()  |
    invoke_db_method()    = (native_method_call(instr.res_var, if instr.db_var? then instr.db_var else "self", user_def_method_name(instr.type, instr.method_id), (instr.args | "env"))),

    init_value_store()    = (native_method_call(instr.store,   "Init",    ())),
    cleanup_value_store() = (native_method_call(instr.store,   "Cleanup", ())),
    init_table()          = (native_method_call(instr.rel_var, "Init",    ())),
    cleanup_table()       = (native_method_call(instr.rel_var, "Cleanup", ())),

    get_table_iter()      = (native_get_table_iter_code(instr.it_var, instr.table, instr.args)),
    set_table()           = (native_set_table_code(instr.relvar, instr.table, instr.state, instr.perm)),
    queue_deletes()       = (native_queue_deletes_code(instr.rel_var, instr.args)),
    queue_insert_value()  = (native_method_call(instr.res_var, instr.store, "Insert", (aux_struct_var_ref_name(instr.store)))),
    queue_insert_tuple()  = (native_method_call(pending_updates_var_ref_name(instr.rel_var), "Insert", instr.tuple)),

    _                     = ();


  String* native_try_block_code(LocVar var, Instr+ body, Maybe[Nat] block_id) = (
    "try {"
    ) & indent_lines(compile_to_c(body, block_id)) & (
    "}",
    "catch (...) {",
    "  " & to_c_var_ref_name(var) & " = null;",
    "}"
  );


//  String* compile_queue_insert_tuple_to_c(RelVar rel_var, IntVar+ tuple) {
//    fn_name = fn_names_by_arity[|tuple|];
//    return (mk_gen_call(fn_name, ("&" & pending_updates_var_ref_name(rel_var)), tuple, ()));
//
//    [NzNat -> String] fn_names_by_arity = [
//      1 -> "unary_table_insert",
//      2 -> "binary_table_insert",
//      3 -> "ternary_table_insert"
//    ];
//  }


//    queue_insert_value()  = (mk_gen_call(instr.res_var, "value_store_insert", (to_c_expr(instr.store), aux_struct_var_ref_name(instr.store)), (instr.value), ())),
//    queue_insert_tuple()  = compile_queue_insert_tuple_to_c(instr.rel_var, instr.tuple);





  String native_set_table_code(RelVar relvar, Table table, AtomicExpr state, Nat+ perm) {
    perm_args = match (perm)
      (_)       = (),
      (0, 1)    = (false),
      (1, 0)    = (true),
      (_, _, _) = perm;
    args = (pending_updates_var_ref_name(relvar)) & table.value_stores &
           (aux_struct_var_ref_name(vs) : vs <- table.value_stores) & perm_args;
    return native_method_call(relvar, "Set", args);
  }



  String native_queue_deletes_code(RelVar relvar, Maybe[IntVar]+ args) {
    fn_name = fn_names_by_args[(a != nothing : a <- args)];
    updates_arg = pending_updates_var_ref_name(relvar);
    return native_method_call(relvar, fn_name, ((value(a) : a <- args, a != nothing) | updates_arg));

    [Bool+ -> String] fn_names_by_args = [
      (true)                  -> "Delete",
      (false)                 -> "Clear",
      (true,  true)           -> "Delete",
      (true,  false)          -> "DeleteByCol1",
      (false, true)           -> "DeleteByCol2",
      (false, false)          -> "Clear",
      (true,  true,  true)    -> "Delete",
      (true,  true,  false)   -> "DeleteByCols12",
      (true,  false, true)    -> "DeleteByCols13",
      (false, true,  true)    -> "DeleteByCols23",
      (true,  false, false)   -> "DeleteByCol1",
      (false, true,  false)   -> "DeleteByCol2",
      (false, false, true)    -> "DeleteByCol3",
      (false, false, false)   -> "Clear"
    ];
  }



  String native_get_table_iter_code(TableItVar it_var, AnyRelVar table, Maybe[IntVar]+ args) {
    fn_name = fn_names_by_args[(a != nothing : a <- args)];
    return native_method_call(it_var, table, fn_name, (value(a) : a <- args, a != nothing));

    [Bool+ -> String] fn_names_by_args = [
      (false)                 -> "GetIter",
      (true,  false)          -> "GetIterByCol1",
      (false, true)           -> "GetIterByCol2",
      (false, false)          -> "GetIter",
      (true,  true,  false)   -> "GetIterByCols12",
      (true,  false, true)    -> "GetIterByCols13",
      (false, true,  true)    -> "GetIterByCols23",
      (true,  false, false)   -> "GetIterByCol1",
      (false, true,  false)   -> "GetIterByCol2",
      (false, false, true)    -> "GetIterByCol3",
      (false, false, false)   -> "GetIter"
    ];
  }


  String native_send_msg_code(AnyDBVar db_var, DBSymbol type, AtomicExpr msg, Bool is_root, Maybe[BoolVar] maybe_res_var) {
    if is_root:
      method_name = update_entry_point_name(type);
      return if maybe_res_var == nothing
        then native_method_call(db_var, method_name, (msg, "env"))
        else native_method_call(value(maybe_res_var), db_var, method_name, (msg, "env"));
    else
      assert db_var :: NestedDBVar;
      fail if not db_var :: NestedDBVar;
      method_name = update_name(type, main_handler);
      aux_db_var_name = aux_struct_var_ref_name(db_var);
      return native_method_call(db_var, update_name(type, main_handler), (msg, aux_db_var_name, "env"));
    ;
  }


  String native_set_state_code(AtomicExpr state, AnyDBVar db_var, DBSymbol type, Maybe[BoolVar] maybe_res_var) {
    if maybe_res_var != nothing:
      return native_method_call(value(maybe_res_var), db_var, set_state_entry_point_name(type), (state));
    else
      fail if not db_var :: NestedDBVar; ## BAD BAD BAD: CHANGE THE DEFINITION OF set_state()
      return native_method_call(db_var, set_state_proc_name(type), (state, aux_struct_var_ref_name(db_var)));
    ;
  }


//  String native_init_db_code(AnyDBVar db_var, LocDBVar* links, DBSymbol type) {
//    links_args = ("&" & to_c_var_ref_name(l) : l <- links);
//    return mk_gen_call(init_method_name(type), ("&" & to_c_var_ref_name(db_var)) & links_args & ("env"));
//  }

//    queue_update()        = compile_queue_update_to_c(instr.type, instr.id, instr.args),
//    insert_timer()        = (insert_timer_method_name(instr.type) & "(self, " & to_c_expr(instr.idx) & ", " & to_c_expr(instr.time) & ");"),
//    clear_timer()         = (clear_timer_method_name(instr.type) & "(self, " & to_c_expr(instr.idx) & ");"),
//    auto_cleanup()        = (cleanup_method_name(instr.type) & "(&" & to_c_var_ref_name(instr.var) & ");"),
//    clear_input()         = { method_name = input_set_method_name(instr.type, instr.input);
//                              target = if instr.var? then "&" & to_c_var_ref_name(instr.var) else "self";
//                              return (method_name & "(" & target & ", make_null_obj());");
//                            },
//    auto_update_node()    = compile_auto_update_node_to_c(instr.type, instr.node, if instr.time_var? then just(instr.time_var) else nothing),
//    auto_apply()          = compile_auto_apply_to_c(if instr.var? then just(instr.var) else nothing, instr.type),
//    set_persistent_state()= compile_set_persistent_state_to_c(instr.auto_var, instr.state, instr.type),
//    init_db()             = (compile_init_db_to_c(instr.db_var, instr.links, instr.type)),
//    cleanup_db()          = (compile_cleanup_db_to_c(instr.db_var, instr.type)),
//    send_msg()            = (compile_send_msg_to_c(instr.db_var, instr.type, instr.msg, instr.is_root, if instr.res_var? then just(instr.res_var) else nothing)),
//    try_update()          = (compile_try_update_to_c(instr.type, instr.update_id, instr.args)),
//    set_state()           = (compile_set_state_to_c(instr.state, instr.db_var, instr.type, if instr.res_var? then just(instr.res_var) else nothing)),
//    invoke_auto_method()  = (compile_invoke_method_to_c(instr.res_var, if instr.auto_var? then just(instr.auto_var) else nothing, instr.type, instr.method_id, instr.args)),
//    invoke_db_method()    = (compile_invoke_method_to_c(instr.res_var, if instr.db_var? then just(instr.db_var) else nothing, instr.type, instr.method_id, instr.args)),
//    init_value_store()    = mk_call("value_store_init", (instr.store)),
//    cleanup_value_store() = mk_call("value_store_cleanup", (instr.store)),
//    init_table()          = compile_init_table_to_c(instr.rel_var, instr.table),
//    cleanup_table()       = compile_cleanup_table_to_c(instr.rel_var, instr.table),
//    set_table()           = compile_set_table_to_c(instr.relvar, instr.table, instr.state, instr.perm),
//    get_table_iter()      = compile_get_table_iter_to_c(instr.it_var, instr.table, instr.args),
//    queue_deletes()       = compile_queue_deletes_to_c(instr.rel_var, instr.args),
//    queue_insert_value()  = (mk_gen_call(instr.res_var, "value_store_insert", (to_c_expr(instr.store), aux_struct_var_ref_name(instr.store)), (instr.value), ())),
//    queue_insert_tuple()  = compile_queue_insert_tuple_to_c(instr.rel_var, instr.tuple);


//  String* native_code_cpp(Instr instr, Maybe[Nat] block_id) =
//    try_block()           = compile_try_block_to_c(instr.var, instr.body, block_id),
//    queue_update()        = compile_queue_update_to_c(instr.type, instr.id, instr.args),
//    insert_timer()        = (insert_timer_method_name(instr.type) & "(self, " & to_c_expr(instr.idx) & ", " & to_c_expr(instr.time) & ");"),
//    clear_timer()         = (clear_timer_method_name(instr.type) & "(self, " & to_c_expr(instr.idx) & ");"),
//    auto_pre_init()       = (pre_init_method_name(instr.type) & "(&" & to_c_var_ref_name(instr.var) & ", env);"),
//    auto_cleanup()        = (cleanup_method_name(instr.type) & "(&" & to_c_var_ref_name(instr.var) & ");"),
//    set_input()           = { value_str = to_c_expr(instr.value);
//                              method_name = input_set_method_name(instr.type, instr.input);
//                              return (method_name & "(&" & to_c_var_ref_name(instr.var) & ", " & value_str & ");");
//                            },
//    clear_input()         = { method_name = input_set_method_name(instr.type, instr.input);
//                              target = if instr.var? then "&" & to_c_var_ref_name(instr.var) else "self";
//                              return (method_name & "(" & target & ", make_null_obj());");
//                            },
//    auto_update_node()    = compile_auto_update_node_to_c(instr.type, instr.node, if instr.time_var? then just(instr.time_var) else nothing),
//    auto_apply()          = compile_auto_apply_to_c(if instr.var? then just(instr.var) else nothing, instr.type),
//    set_persistent_state()= compile_set_persistent_state_to_c(instr.auto_var, instr.state, instr.type),
//    init_db()             = (compile_init_db_to_c(instr.db_var, instr.links, instr.type)),
//    cleanup_db()          = (compile_cleanup_db_to_c(instr.db_var, instr.type)),
//    send_msg()            = (compile_send_msg_to_c(instr.db_var, instr.type, instr.msg, instr.is_root, if instr.res_var? then just(instr.res_var) else nothing)),
//    try_update()          = (compile_try_update_to_c(instr.type, instr.update_id, instr.args)),
//    set_state()           = (compile_set_state_to_c(instr.state, instr.db_var, instr.type, if instr.res_var? then just(instr.res_var) else nothing)),
//    invoke_auto_method()  = (compile_invoke_method_to_c(instr.res_var, if instr.auto_var? then just(instr.auto_var) else nothing, instr.type, instr.method_id, instr.args)),
//    invoke_db_method()    = (compile_invoke_method_to_c(instr.res_var, if instr.db_var? then just(instr.db_var) else nothing, instr.type, instr.method_id, instr.args)),
//    init_value_store()    = ("UNKNOWN"),
//    cleanup_value_store() = ("UNKNOWN"),
//    init_table()          = ("UNKNOWN"),
//    cleanup_table()       = ("UNKNOWN"),
//    set_table()           = compile_set_table_to_c(instr.relvar, instr.table, instr.state, instr.perm),
//    get_table_iter()      = compile_get_table_iter_to_c(instr.it_var, instr.table, instr.args),
//    queue_deletes()       = compile_queue_deletes_to_c(instr.rel_var, instr.args),
//    queue_insert_value()  = (mk_gen_call(instr.res_var, "value_store_insert", (to_c_expr(instr.store), aux_struct_var_ref_name(instr.store)), (instr.value), ())),
//    queue_insert_tuple()  = compile_queue_insert_tuple_to_c(instr.rel_var, instr.tuple);
//
//
//  String* compile_set_persistent_state_to_c(AnyAutoVar auto_var, AtomicExpr state, AutoSymbol type) {
//    proc_name = set_state_proc_name(type);
//    return (proc_name & "(&" & to_c_var_ref_name(auto_var) & ", " & to_c_expr(state) & ");");
//  }
//
//
//  String* compile_queue_update_to_c(AutoSymbol type, BlockNodeId node_id, Nat* args) {
//    method_name = queue_update_method_name(type, node_id);
//    args_str = append((", " & printed(a) : a <- args));
//    return (method_name & "(self" & args_str & ");");
//  }
//
//
//  String* compile_set_table_to_c(RelVar relvar, Table table, AtomicExpr state, Nat+ perm) {
//    fn_name = fn_names[arity(table)];
//    perm_args = match (perm)
//      (_)       = (),
//      (0, 1)    = (false),
//      (1, 0)    = (true),
//      (_, _, _) = perm;
//    str_args = ("&" & to_c_var_ref_name(relvar), "&" & pending_updates_var_ref_name(relvar)) &
//               (to_c_var_ref_name(vs) : vs <- table.value_stores) &
//               (aux_struct_var_ref_name(vs) : vs <- table.value_stores);
//    return (mk_gen_call(fn_name, str_args, (state) & perm_args, ()));
//
//    [NzNat -> String] fn_names = [
//      1 -> "set_unary_table",
//      2 -> "set_binary_table",
//      3 -> "set_ternary_table"
//    ];
//  }
//
//  String* compile_try_block_to_c(LocVar var, Instr+ body, Maybe[Nat] block_id) {
//    var_name = to_c_var_ref_name(var);
//    body_code = compile_to_c(body, block_id);
//
//    return (
//      "int depth = get_call_stack_depth();",
//      "enter_try_state();",
//      "try {"
//      ) & indent_lines(body_code) & (
//      "  enter_copy_state();",
//      "  " & var_name & " = copy_obj(" & var_name & ");",
//      "  return_to_normal_state();",
//      "}",
//      "catch (...) {",
//      "  pop_try_mode_call_info(depth);",
//      "  abort_try_state();",
//      "  " & var_name & " = make_null_obj();",
//      "}"
//    );
//  }


//  String* compile_init_table_to_c(RelVar rel_var, Table table) {
//    fn_name = fn_names_by_arity[arity(table)];
//    return mk_call(fn_name, (rel_var));
//
//    [NzNat -> String] fn_names_by_arity = [
//      1 -> "unary_table_init",
//      2 -> "binary_table_init",
//      3 -> "ternary_table_init"
//    ];
//  }
//
//
//  String* compile_cleanup_table_to_c(RelVar rel_var, Table table) {
//    fn_name = fn_names_by_arity[arity(table)];
//    return mk_call(fn_name, (rel_var));
//
//    [NzNat -> String] fn_names_by_arity = [
//      1 -> "unary_table_cleanup",
//      2 -> "binary_table_cleanup",
//      3 -> "ternary_table_cleanup"
//    ];
//  }


  // String* compile_queue_deletes_to_c(RelVar rel_var, Maybe[IntVar]+ args) {
  //   fn_name = fn_names_by_args[(a != nothing : a <- args)];
  //   table_arg_str = "&" & to_c_var_ref_name(rel_var);
  //   updates_arg_str = "&" & pending_updates_var_ref_name(rel_var);
  //   return (mk_gen_call(fn_name, (table_arg_str, updates_arg_str), (value(a) : a <- args, a != nothing), ()));

  //   [Bool+ -> String] fn_names_by_args = [
  //     (true)                  -> "unary_table_delete",
  //     (false)                 -> "unary_table_clear",
  //     (true,  true)           -> "binary_table_delete",
  //     (true,  false)          -> "binary_table_delete_by_col_0",
  //     (false, true)           -> "binary_table_delete_by_col_1",
  //     (false, false)          -> "binary_table_clear",
  //     (true,  true,  true)    -> "ternary_table_delete",
  //     (true,  true,  false)   -> "ternary_table_delete_by_cols_01",
  //     (true,  false, true)    -> "ternary_table_delete_by_cols_02",
  //     (false, true,  true)    -> "ternary_table_delete_by_cols_12",
  //     (true,  false, false)   -> "ternary_table_delete_by_col_0",
  //     (false, true,  false)   -> "ternary_table_delete_by_col_1",
  //     (false, false, true)    -> "ternary_table_delete_by_col_2",
  //     (false, false, false)   -> "ternary_table_clear"
  //   ];
  // }


  // String* compile_queue_insert_tuple_to_c(RelVar rel_var, IntVar+ tuple) {
  //   fn_name = fn_names_by_arity[|tuple|];
  //   return (mk_gen_call(fn_name, ("&" & pending_updates_var_ref_name(rel_var)), tuple, ()));

  //   [NzNat -> String] fn_names_by_arity = [
  //     1 -> "unary_table_insert",
  //     2 -> "binary_table_insert",
  //     3 -> "ternary_table_insert"
  //   ];
  // }


  // String* compile_get_table_iter_to_c(TableItVar it_var, AnyRelVar table, Maybe[IntVar]+ args) {
  //   fn_name = fn_names_by_args[(a != nothing : a <- args)];
  //   return (fn_name);
  //   //return mk_call(fn_name, (table, it_var) & (value(a) : a <- args, a != nothing));

  //   [Bool+ -> String] fn_names_by_args = [
  //     (false)                 -> "unary_table_get_iter",
  //     (true,  false)          -> "binary_table_get_iter_by_col_0",
  //     (false, true)           -> "binary_table_get_iter_by_col_1",
  //     (false, false)          -> "binary_table_get_iter",
  //     (true,  true,  false)   -> "ternary_table_get_iter_by_cols_01",
  //     (true,  false, true)    -> "ternary_table_get_iter_by_cols_02",
  //     (false, true,  true)    -> "ternary_table_get_iter_by_cols_12",
  //     (true,  false, false)   -> "ternary_table_get_iter_by_col_0",
  //     (false, true,  false)   -> "ternary_table_get_iter_by_col_1",
  //     (false, false, true)    -> "ternary_table_get_iter_by_col_2",
  //     (false, false, false)   -> "ternary_table_get_iter"
  //   ];
  // }

  // String compile_init_db_to_c(AnyDBVar db_var, LocDBVar* links, DBSymbol type) {
  //   links_args = ("&" & to_c_var_ref_name(l) : l <- links);
  //   return mk_gen_call(init_method_name(type), ("&" & to_c_var_ref_name(db_var)) & links_args & ("env"));
  // }


  // String compile_cleanup_db_to_c(AnyDBVar db_var, DBSymbol type) =
  //   mk_gen_call(cleanup_method_name(type), ("&" & to_c_var_ref_name(db_var)));


  // String compile_send_msg_to_c(AnyDBVar db_var, DBSymbol type, AtomicExpr msg, Bool is_root, Maybe[BoolVar] maybe_res_var) {
  //   if is_root:
  //     name_str = update_entry_point_name(type);
  //     db_var_str = "&" & to_c_var_ref_name(db_var);
  //     return if maybe_res_var == nothing
  //       then mk_gen_call(name_str, (db_var_str), (msg), ("env"))
  //       else mk_gen_call(value(maybe_res_var), name_str, (db_var_str), (msg), ("env"));
  //   else
  //     assert db_var :: NestedDBVar;
  //     fail if not db_var :: NestedDBVar;
  //     name_str = update_name(type, main_handler);
  //     db_var_str = "&" & to_c_var_ref_name(db_var);
  //     aux_db_var_str = aux_struct_var_ref_name(db_var);
  //     return mk_gen_call(name_str, (db_var_str, aux_db_var_str), (msg), ("env")) & " /" & "/ HEREHEREHERE";
  //   ;
  // }


  // String compile_try_update_to_c(DBSymbol type, UpdateId id, AtomicExpr* args) =
  //   mk_gen_call(update_name(type, id), ("self, self_aux"), args, ("env"));


  // String compile_set_state_to_c(AtomicExpr state, AnyDBVar db_var, DBSymbol type, Maybe[BoolVar] maybe_res_var) {
  //   if maybe_res_var != nothing:
  //     proc_name_str = set_state_entry_point_name(type);
  //     db_var_str = "&" & to_c_var_ref_name(db_var);
  //     return mk_gen_call(value(maybe_res_var), proc_name_str, (db_var_str), (state), ());
  //   else
  //     fail if not db_var :: NestedDBVar; ## BAD BAD BAD: CHANGE THE DEFINITION OF set_state()
  //     proc_name_str = set_state_proc_name(type);
  //     self_and_aux_vars = ("&" & to_c_var_ref_name(db_var), aux_struct_var_ref_name(db_var));
  //     return mk_gen_call(proc_name_str, self_and_aux_vars, (state), ());
  //   ;
  // }


  // String compile_invoke_method_to_c(WriteObjVar res_var, Maybe[<AnyAutoVar, AnyDBVar>] maybe_target_var,
  //   <AutoSymbol, DBSymbol> type, MethodId id, AtomicExpr* args) {
  //   name_str = user_def_method_name(type, id);
  //   target_var_str = if maybe_target_var != nothing then "&" & to_c_var_ref_name(value(maybe_target_var)) else "self";
  //   return mk_gen_call(res_var, name_str, (target_var_str), args, ("env"));
  // }


  // String* compile_auto_update_node_to_c(AutoSymbol type, BlockNodeId node, Maybe[IntVar] maybe_time_var) {
  //   time_arg = if maybe_time_var != nothing then ", " & to_c_var_ref_name(value(maybe_time_var)) else "";
  //   return (node_update_method_name(type, node) & "(self" & time_arg & ", self_aux, env);");
  // }


  // String* compile_auto_apply_to_c(Maybe[AnyAutoVar] var, AutoSymbol type) {
  //   var_str = if var != nothing then "&" & to_c_var_ref_name(value(var)) else "self";
  //   name_str = apply_method_name(type);
  //   return (mk_gen_call(name_str, (var_str), (), ("env")));
  // }


  // String compile_copy_state_to_c(WriteObjVar res_var, AnyDBVar db_var, DBSymbol type) {
  //   proc_name_str = copy_state_proc_name(type);
  //   db_var_str = "&" & to_c_var_ref_name(db_var);
  //   return mk_gen_call(res_var, proc_name_str, (db_var_str), (), ());
  // }


  // ## BAD: IT'S EXACTLY THE SAME AS THE ABOVE FUNCTIONS, BUT THE TYPECHECKER...
  // String compile_copy_persistent_state_to_c(WriteObjVar res_var, AnyAutoVar auto_var, AutoSymbol type) {
  //   proc_name_str = copy_state_proc_name(type);
  //   auto_var_str = "&" & to_c_var_ref_name(auto_var);
  //   return mk_gen_call(res_var, proc_name_str, (auto_var_str), (), ());
  // }


  // String compile_copy_table_to_c(WriteObjVar res_var, RelVar relvar, Table table, Nat+ perm) {
  //   fn_name = fn_names[arity(table)];
  //   perm_args = match (perm)
  //     (_)       = (),
  //     (0, 1)    = (false),
  //     (1, 0)    = (true),
  //     (_, _, _) = perm;
  //   args = (relvar) & table.value_stores & perm_args;
  //   return fn_name;
  //   //return mk_call(res_var, fn_name, args);

  //   [NzNat -> String] fn_names = [
  //     1 -> "copy_unary_table",
  //     2 -> "copy_binary_table",
  //     3 -> "copy_ternary_table"
  //   ];
  // }
}
