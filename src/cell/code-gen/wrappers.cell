type AtomicInterType  = bool, integer, float, symbol, string;
type BasicInterType   = AtomicInterType, generic;
type InterType        = BasicInterType, tuple(InterType+), seq(InterType), set(InterType), tagged(InterType);


NeType internal_type(AtomicInterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  symbol      = atom_type,
  string      = type_string;


String input_arg_type(BasicInterType) =
  bool        = "bool",
  integer     = "long",
  float       = "double",
  symbol      |
  string      |
  generic     = "string";


String constructor_function(InterType) =
  bool        = "SymbObj.Get",
  integer     = "IntObj.Get",
  float       = "new FloatObj",
  symbol      = "Conversions.ConvertText",
  string      = "Conversions.StringToObj",
  generic     = "Conversions.ConvertText";


String return_value_type(InterType) =
  bool        = "bool",
  integer     = "long",
  float       = "double",
  symbol      = "string",
  string      = "string",
  tuple(ts?)  = "Tuple<" & append((return_value_type(t) : t <- ts), ", ") & ">",
  seq(t?)     |
  set(t?)     = return_value_type(t) & "[]",
  tagged(t?)  = if t != :generic then return_value_type(t) else return_value_type(:generic),
  generic     = "Value";


String* export_code(InterType it, String expr, String action_prefix) =
  bool            = (action_prefix & expr & ".GetBool();"),
  integer         = (action_prefix & expr & ".GetLong();"),
  float           = (action_prefix & expr & ".GetDouble();"),
  symbol          = (action_prefix & expr & ".ToString();"),
  string          = (action_prefix & expr & ".GetString();"),
  tuple(ts?)      = tuple_export_code(ts, expr, action_prefix),
  seq(t?)         |
  set(t?)         = array_export_code(t, expr, action_prefix),
  tagged(generic) = export_code(:generic, expr, action_prefix),
  tagged(t?)      = export_code(t, expr & ".GetInnerObj()", action_prefix),
  generic         = (action_prefix & "Conversions.ExportAsValue(" & expr & ");");


String* tuple_export_code(InterType+ types, String expr, String action_prefix) {
  unique_id = printed(_counter_(:any_value_will_do));
  expr_var = "expr" & unique_id;

  field_vars = ("field" & printed(i) & "_" & unique_id : t @ i <- types);
  fields_code = join(({
      asgnm_text = return_value_type(t) & " " & field_vars(i) & " = ";
      return export_code(t, expr & ".GetItem(" & printed(i) & ")", asgnm_text);
    } : t @ i <- types
  ));

  tuple_instr = action_prefix & "new Tuple<" & append((return_value_type(t) : t <- types), ", ") &
                ">(" & append(field_vars, ", ") & ");";

  return (fields_code | tuple_instr);
}


String* array_export_code(InterType elem_type, String expr, String action_prefix) {
  return match (elem_type)
    bool            = (action_prefix & "Conversions.ToBoolArray(" & expr & ");"),
    integer         = (action_prefix & "Conversions.ToLongArray(" & expr & ");"),
    float           = (action_prefix & "Conversions.ToDoubleArray(" & expr & ");"),
    symbol          = (action_prefix & "Conversions.ToSymbolArray(" & expr & ");"),
    string          = (action_prefix & "Conversions.ToStringArray(" & expr & ");"),
    generic         = (action_prefix & "Conversions.ToValueArray(" & expr & ");"),
    tagged(generic) = array_export_code(:generic, expr, action_prefix),
    tuple()         |
    seq()           |
    set()           |
    tagged()        = generic_array_export_code(elem_type, expr, action_prefix);


  String* generic_array_export_code(InterType elem_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;
    size_var = "size" & unique_id;
    array_var = "array" & unique_id;
    iter_var = "iter" & unique_id;
    idx_var = "idx" & unique_id;
    out_elem_type = return_value_type(elem_type);

    return (
      "Obj " & expr_var & " = " & expr & ";",
      "int " & size_var & " = " & expr_var & ".GetSize();",
      out_elem_type & "[] " & array_var & " = new " & array_new_expr(elem_type, size_var) & ";",
      "SeqOrSetIter " & iter_var & " = " & expr_var & ".GetSeqOrSetIter();",
      "int " & idx_var & " = 0;",
      "while (!" & iter_var & ".Done()) {"
    ) & indent_lines(export_code(elem_type, iter_var & ".Get()", array_var & "[" & idx_var & "++] = ")) & (
      "  " & iter_var & ".Next();",
      "}",
      "Miscellanea.Assert(" & idx_var & " == " & size_var & ");",
      action_prefix & array_var & ";"
    );
  }
}


String array_new_expr(InterType elem_type, String size_expr) =
  seq(t?) | set(t?) = array_new_expr(t, size_expr) & "[]",
  _                 = return_value_type(elem_type) & "[" & size_expr & "]";

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  BasicInterType input_interface_type(NeType type) {
    for it <- (:bool, :integer, :float, :symbol, :string):
      return it if is_subset(type, internal_type(it));
    ;
    return :generic;
  }


  InterType output_interface_type(NeType type) {
    for it <- (:bool, :integer, :float, :symbol, :string):
      return it if is_subset(type, internal_type(it));
    ;

    maybe_types = maybe_tuple_type_fields(type);
    if maybe_types != nothing:
      types = value(maybe_types);
      size = |types|;
      return :tuple((output_interface_type(t) : t <- types)) if size >= 2 and size <= 6;
    ;

    if is_subset(type, type_seq):
      elem_type = seq_elem_supertype(type);
      return :seq(output_interface_type(elem_type)) if elem_type != empty_type;
    ;

    if is_subset(type, type_set):
      elem_type = set_elem_supertype(type);
      return :set(output_interface_type(elem_type)) if elem_type != empty_type;
    ;

    if is_subset(type, type_tagged_obj):
      tag_type = tag_supertype(type);
      if is_symb_singl_type(tag_type):
        obj_type = untagged_objs_supertype(type);
        return :tagged(output_interface_type(obj_type)) if obj_type != empty_type;
      ;
    ;

    return :generic;
  }
}
